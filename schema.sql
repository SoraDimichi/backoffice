create type public.app_permission as enum ('public.users.update', 'public.users.select', 'public.delete_user', 'public.create_user', 'public.transactions.select');
create type public.app_role as enum ('admin', 'user', 'guest');

create table public.users (
  id       uuid references auth.users not null primary key,
  username text,
  role     public.app_role default 'user'::public.app_role
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal supabase auth user.';

create table public.role_permissions (
  id         bigint generated by default as identity primary key,
  role       public.app_role not null,
  permission public.app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

create or replace function public.authorize(
  requested_permission public.app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
    from public.role_permissions
    where role_permissions.permission = authorize.requested_permission
      and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
    into bind_permissions;

  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

create policy "admin can update public.users" on public.users for update using (public.authorize('public.users.update'));
create policy "admin can select public.users" on public.users for select using (public.authorize('public.users.select'));

alter table public.role_permissions enable row level security;
alter table public.users enable row level security;
alter table public.users replica identity full;

create or replace function public.handle_new_user()
returns trigger as $$
DECLARE
    first_name TEXT:= new.raw_user_meta_data->>'first_name';
    last_name  TEXT:= new.raw_user_meta_data->>'last_name';
    full_name  TEXT:= NULLIF(TRIM(COALESCE(first_name, '') || ' ' || COALESCE(last_name, '')), '');
begin
    insert into public.users (id, username, role)
    values (new.id, full_name, 'user')
    on conflict (id) do nothing;

    return NEW;
end;
$$ language plpgsql security definer set search_path = auth, public;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;

alter publication supabase_realtime add table public.users;

create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims    jsonb;
    user_role public.app_role;
  begin
    claims := event->'claims';
    select role
      into user_role
      from public.users
      where id = (event->>'user_id')::uuid;

    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    event := jsonb_set(event, '{claims}', claims);

    return event;
  end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;
revoke all on table public.users from anon, public;
grant all on table public.users to authenticated, supabase_auth_admin;
grant all on table auth.users to authenticated, supabase_auth_admin;
create policy "allow auth admin to read users" on public.users as permissive for select to supabase_auth_admin using (true);

create or replace function public.create_user(
    username text,
    password text,
    role public.app_role
) returns uuid
as $$
declare
    user_id uuid;
begin
    user_id := extensions.uuid_generate_v4();

    insert into public.users (id, username, role)
        values (user_id, username, role);

    insert into auth.users (id, email, role, encrypted_password)
        values (user_id, username, 'authenticated', extensions.crypt(password, extensions.gen_salt('bf')))
        returning id into user_id;

    return user_id;
end;
$$ language plpgsql security definer set search_path = auth, public;
grant execute on function public.create_user(text, text, public.app_role) to authenticated;

CREATE OR REPLACE FUNCTION public.delete_user(
    p_user_id UUID 
) RETURNS UUID 
AS $$
BEGIN
    IF NOT public.authorize('public.delete_user') THEN
        RAISE EXCEPTION 'insufficient privileges. must have public.delete_user permission.';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = p_user_id) THEN
        RAISE EXCEPTION 'user with id % does not exist.', p_user_id;
    END IF;

    DELETE FROM public.transactions WHERE user_id = p_user_id;
    DELETE FROM public.users WHERE id = p_user_id;
    DELETE FROM auth.users WHERE id = p_user_id;

    RETURN p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = auth, public;
GRANT EXECUTE ON FUNCTION public.delete_user(UUID) TO authenticated;

CREATE OR REPLACE FUNCTION public.create_user_internal(
    email TEXT,
    password TEXT,
    role public.app_role,
    first_name TEXT DEFAULT NULL,
    last_name TEXT DEFAULT NULL,
    last_sign_in TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
) RETURNS UUID AS $$
DECLARE
    user_id UUID;
    encrypted_pw TEXT;
    user_role public.app_role;
BEGIN
    user_id := extensions.gen_random_uuid();
    encrypted_pw := extensions.crypt(password, extensions.gen_salt('bf'));

    INSERT INTO auth.users (
        instance_id,
        id,
        aud,
        role,
        email,
        encrypted_password,
        email_confirmed_at,
        recovery_sent_at,
        last_sign_in_at,
        raw_app_meta_data,
        raw_user_meta_data,
        created_at,
        updated_at,
        confirmation_token,
        email_change,
        email_change_token_new,
        recovery_token
    ) 
    SELECT
        '00000000-0000-0000-0000-000000000000',
        user_id,
        'authenticated',
        'authenticated',
        email,
        encrypted_pw,
        created_at,
        NULL,
        COALESCE(last_sign_in, created_at),
        '{"provider":"email","providers":["email"]}',      
        JSONB_BUILD_OBJECT(
            'sub', user_id::TEXT,
            'email', email,
            'email_verified', 'true',
            'phone_verified', 'false',
            'first_name', first_name,
            'last_name', last_name
        ),
        created_at,
        COALESCE(updated_at, created_at),
        '',
        '',
        '',
        '';
   
    INSERT INTO auth.identities (
        id,
        provider_id,
        user_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
    ) VALUES (
        extensions.gen_random_uuid(),
        user_id,
        user_id,
        JSONB_BUILD_OBJECT(
            'sub', user_id::TEXT,
            'email', email,
            'email_verified', 'true',
            'phone_verified', 'false'
        ),
        'email',
        COALESCE(last_sign_in, created_at),
        created_at,
        COALESCE(updated_at, created_at)
    );

    user_role := role;
    UPDATE public.users SET role = user_role WHERE id = user_id;

    RETURN user_id;
END;
$$ language plpgsql security definer set search_path = auth, public;
revoke execute on function public.create_user_internal(text, text, public.app_role, text, text, timestamptz, timestamptz, timestamptz) from authenticated, anon, public;

CREATE OR REPLACE FUNCTION public.create_user(
    email TEXT,
    password TEXT,
    role public.app_role,
    first_name TEXT DEFAULT NULL,
    last_name TEXT DEFAULT NULL,
    last_sign_in TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
) RETURNS UUID AS $$
BEGIN
    IF NOT public.authorize('public.create_user') THEN
        RAISE EXCEPTION 'Insufficient privileges. Must have public.create_user permission.';
    END IF;

    RETURN public.create_user_internal(
        email,
        password,
        role,
        first_name,
        last_name,
        last_sign_in,
        created_at,
        updated_at
    );
END;
$$ language plpgsql security definer set search_path = auth, public;
grant execute on function public.create_user(text, text, public.app_role, text, text, timestamptz, timestamptz, timestamptz) to authenticated;


-- Transactions
CREATE TYPE public.transaction_type AS ENUM ('deposit', 'credit');
CREATE TYPE public.transaction_status AS ENUM ('pending', 'completed', 'failed');
CREATE TYPE public.transaction_subtype AS ENUM ('refund', 'reward', 'purchase');

CREATE TABLE public.transactions (
  id UUID PRIMARY KEY,
  user_id uuid references auth.users not null,
  description TEXT,
  type public.transaction_type NOT NULL,
  subtype public.transaction_subtype NOT NULL,
  amount DECIMAL(10, 2) NOT NULL,
  status public.transaction_status NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.transactions IS 'Stores all user transactions with their details.';
COMMENT ON COLUMN public.transactions.user_id IS 'Foreign key referencing the user in the auth.users table.';
alter table public.transactions enable row level security;


CREATE VIEW transactions_with_username WITH (security_invoker = true) AS
SELECT 
    t.id AS transaction_id, 
    u.username, 
    t.description, 
    t.amount, 
    t.type,
    t.subtype,
    t.status,
    t.created_at,
FROM public.transactions t
JOIN public.users u ON t.user_id = u.id;

create policy "admin can select public.transactions" on public.transactions for select using (public.authorize('public.transactions.select'));
create policy "user can select public.transactions" on public.transactions for select using (public.authorize('public.transactions.select'));


CREATE OR REPLACE FUNCTION public.get_revenue_current_month()
RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
    start_date  TIMESTAMP;
    end_date    TIMESTAMP;
    date_range  TEXT;
    total_value NUMERIC;
BEGIN
    IF NOT public.authorize('public.transactions.select') THEN
        RAISE EXCEPTION 'Insufficient privileges. Must have public.transactions.select permission.';
    END IF;

    start_date := date_trunc('month', now());
    end_date   := now();

    date_range := to_char(start_date, 'FMDD FMMonth') || ' - ' 
                  || to_char(end_date, 'FMDD FMMonth');

    SELECT COALESCE(SUM(amount), 0)
      INTO total_value
      FROM public.transactions
     WHERE status = 'completed'
       AND subtype IN ('reward', 'purchase')
       AND created_at >= start_date
       AND created_at <= end_date;

    RETURN (
       SELECT jsonb_build_object(
         'type', 'month',
         'range', date_range,
         'total', total_value,
         'revenues', COALESCE(
            jsonb_agg(
              jsonb_build_object(
                'subtype', t.subtype,
                'revenue', t.sub_amount
              )
            ),
            '[]'::jsonb
         )
       )
       FROM (
         SELECT subtype, SUM(amount) AS sub_amount
           FROM public.transactions
          WHERE status = 'completed'
            AND subtype IN ('reward', 'purchase')
            AND created_at >= start_date
            AND created_at <= end_date
          GROUP BY subtype
       ) t
    );
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_revenue_current_month() TO authenticated;

CREATE OR REPLACE FUNCTION public.get_revenue_current_week()
RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
    start_date  TIMESTAMP;
    end_date    TIMESTAMP;
    date_range  TEXT;
    total_value NUMERIC;
BEGIN
    IF NOT public.authorize('public.transactions.select') THEN
        RAISE EXCEPTION 'Insufficient privileges. Must have public.transactions.select permission.';
    END IF;
    start_date := date_trunc('week', now()::date + 1);
    end_date   := now();

    date_range := to_char(start_date, 'FMDD FMMonth') || ' - ' || to_char(end_date, 'FMDD FMMonth');

    SELECT COALESCE(SUM(amount), 0)
      INTO total_value
      FROM public.transactions
     WHERE status = 'completed'
       AND subtype IN ('reward', 'purchase')
       AND created_at >= start_date
       AND created_at <= end_date;

    RETURN (
       SELECT jsonb_build_object(
         'type', 'week',
         'range', date_range,
         'total', total_value,
         'revenues', COALESCE(
            jsonb_agg(
              jsonb_build_object(
                'subtype', t.subtype,
                'revenue', t.sub_amount
              )
            ),
            '[]'::jsonb
         )
       )
       FROM (
         SELECT subtype, SUM(amount) AS sub_amount
           FROM public.transactions
          WHERE status = 'completed'
            AND subtype IN ('reward', 'purchase')
            AND created_at >= start_date
            AND created_at <= end_date
          GROUP BY subtype
       ) t
    );
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_revenue_current_week() TO authenticated;

insert into public.role_permissions (role, permission)
values
    ('admin', 'public.users.update'),
    ('admin', 'public.users.select'),
    ('admin', 'public.create_user'),
    ('admin', 'public.delete_user'),
    ('user', 'public.transactions.select'),
    ('admin', 'public.transactions.select');
