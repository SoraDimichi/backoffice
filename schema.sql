drop type if exists public.app_permission cascade;
drop type if exists public.app_role cascade;

create type public.app_permission as enum ('public.users.update', 'public.users.select', 'public.delete_user', 'public.create_user');
create type public.app_role as enum ('admin', 'user', 'guest');

drop table if exists public.users cascade;
create table public.users (
  id       uuid references auth.users not null primary key, -- uuid from auth.users
  username text,
  role     public.app_role default 'user'::public.app_role
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal supabase auth user.';

drop table if exists public.role_permissions cascade;
create table public.role_permissions (
  id         bigint generated by default as identity primary key,
  role       public.app_role not null,
  permission public.app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

create or replace function public.authorize(
  requested_permission public.app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
    from public.role_permissions
    where role_permissions.permission = authorize.requested_permission
      and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
    into bind_permissions;

  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

insert into public.role_permissions (role, permission)
values
    ('admin', 'public.users.update'),
    ('admin', 'public.users.select'),
    ('admin', 'public.create_user'),
    ('admin', 'public.delete_user');

create policy "admin can update public.users" on public.users for update using (public.authorize('public.users.update'));
create policy "admin can select public.users" on public.users for select using (public.authorize('public.users.select'));

alter table public.role_permissions enable row level security;
alter table public.users enable row level security;
alter table public.users replica identity full;

create or replace function public.handle_new_user()
returns trigger as $$
begin
    insert into public.users (id, username)
    values (NEW.id, NEW.email)
    on conflict (id) do nothing;

    if position('+supaadmin@' in NEW.email) > 0 then
        update public.users
        set role = 'admin'
        where id = NEW.id;
    end if;

    return NEW;
end;
$$ language plpgsql security definer set search_path = auth, public;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;

alter publication supabase_realtime add table public.users;

create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims    jsonb;
    user_role public.app_role;
  begin
    claims := event->'claims';
    select role
      into user_role
      from public.users
      where id = (event->>'user_id')::uuid;

    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    event := jsonb_set(event, '{claims}', claims);

    return event;
  end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;
revoke all on table public.users from anon, public;
grant all on table public.users to authenticated, supabase_auth_admin;
grant all on table auth.users to authenticated, supabase_auth_admin;
create policy "allow auth admin to read users" on public.users as permissive for select to supabase_auth_admin using (true);

create or replace function public.create_user(
    username text,
    password text,
    role public.app_role
) returns uuid
as $$
declare
    user_id uuid;
begin
    user_id := extensions.uuid_generate_v4();

    insert into public.users (id, username, role)
        values (user_id, username, role);

    insert into auth.users (id, email, role, encrypted_password)
        values (user_id, username, 'authenticated', extensions.crypt(password, extensions.gen_salt('bf')))
        returning id into user_id;

    return user_id;
end;
$$ language plpgsql security definer set search_path = auth, public;

grant execute on function public.create_user(text, text, public.app_role) to authenticated;

create or replace function public.delete_user(
    user_id uuid 
) returns void
as $$
begin
    if not public.authorize('public.delete_user') then
        raise exception 'insufficient privileges. must have public.delete_user permission.';
    end if;

    if not exists (select 1 from auth.users where id = user_id) then
        raise exception 'user with id % does not exist.', user_id;
    end if;

    delete from public.users
    where id = user_id;

    delete from auth.users
    where id = user_id;

    return;
end;
$$ language plpgsql security definer set search_path = auth, public;
grant execute on function public.delete_user(uuid) to authenticated;

create or replace function public.create_user(
    email text,
    password text,
    role public.app_role,
    first_name text default null,
    last_name text default null,
    last_sign_in timestamp with time zone default null,
    created_at timestamp with time zone default now(),
    updated_at timestamp with time zone default now()
) returns uuid as $$
declare
    user_id uuid;
    encrypted_pw text;
    user_role public.app_role;
begin
    if not public.authorize('public.create_user') then
        raise exception 'insufficient privileges. must have public.create_user permission.';
    end if;

    user_id := extensions.gen_random_uuid();
    encrypted_pw := extensions.crypt(password, extensions.gen_salt('bf'));

    -- construct the name
    with name_construction as (
        select nullif(trim(coalesce(first_name, '') || ' ' || coalesce(last_name, '')), '') as full_name
    )
    insert into auth.users (
        instance_id,
        id,
        aud,
        role,
        email,
        encrypted_password,
        email_confirmed_at,
        recovery_sent_at,
        last_sign_in_at,
        raw_app_meta_data,
        raw_user_meta_data,
        created_at,
        updated_at,
        confirmation_token,
        email_change,
        email_change_token_new,
        recovery_token
    ) 
    select
        '00000000-0000-0000-0000-000000000000',
        user_id,
        'authenticated',
        'authenticated',
        email,
        encrypted_pw,
        created_at, -- using created_at as email_confirmed_at
        null,
        coalesce(last_sign_in, created_at),
        '{"provider":"email","providers":["email"]}',      
        jsonb_build_object(
            'sub', user_id::text,
            'email', email,
            'email_verified', 'true',
            'phone_verified', 'false'     
        ),
        created_at,
        coalesce(updated_at, created_at),
        '',
        '',
        '',
        ''
    from name_construction;
   
    insert into auth.identities (
        id,
        provider_id,
        user_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
    ) values (
        gen_random_uuid(),
        user_id,
        user_id,
        jsonb_build_object(
            'sub', user_id::text,
            'email', email,
            'email_verified', 'true',
            'phone_verified', 'false'
        ),
        'email',
        coalesce(last_sign_in, created_at),
        created_at,
        coalesce(updated_at, created_at)
    );

    user_role := role;

     update public.users set role = user_role where id = user_id;

    return user_id;
end;
$$ language plpgsql security definer set search_path = auth, public;
grant execute on function public.create_user(text, text, public.app_role, text, text, timestamptz, timestamptz, timestamptz) to authenticated;
