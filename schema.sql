-- Remove existing types
drop type if exists public.app_permission cascade;
drop type if exists public.app_role cascade;

-- Create the enums
create type public.app_permission as enum ('users.all');
create type public.app_role as enum ('admin', 'user');

-- USERS
drop table if exists public.users cascade;
create table public.users (
  id       uuid references auth.users not null primary key, -- UUID from auth.users
  username text,
  role     public.app_role default 'user'::public.app_role
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal Supabase Auth user.';

-- ROLE PERMISSIONS
drop table if exists public.role_permissions cascade;
create table public.role_permissions (
  id         bigint generated by default as identity primary key,
  role       public.app_role not null,
  permission public.app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';


-- Authorize with role-based access control (RBAC)
create or replace function public.authorize(
  requested_permission public.app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
    from public.role_permissions
    where role_permissions.permission = authorize.requested_permission
      and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
    into bind_permissions;

  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

-- Enable row level security
alter table public.role_permissions enable row level security;

-- Send "previous data" on change
alter table public.users replica identity full;

-- Inserts a row into public.users and assigns role if +supaadmin@
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.users (id, username)
    values (new.id, new.email);

  if position('+supaadmin@' in new.email) > 0 then
    update public.users
      set role = 'admin'
      where id = new.id;
  end if;

  return new;
end;
$$ language plpgsql security definer set search_path = auth, public;

CREATE POLICY "Admin can everything" ON public.users FOR ALL USING (public.authorize('users.all'));
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
INSERT INTO public.role_permissions (role, permission) VALUES ('admin', 'users.all'), ON CONFLICT (role, permission) DO NOTHING;

-- Trigger the function every time a user is created
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- REALTIME SUBSCRIPTIONS
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;

-- Only add users table to the publication
alter publication supabase_realtime add table public.users;

-- AUTH HOOKS: create a custom access token hook
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims    jsonb;
    user_role public.app_role;
  begin
    claims := event->'claims';
    select role
      into user_role
      from public.users
      where id = (event->>'user_id')::uuid;

    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    event := jsonb_set(event, '{claims}', claims);

    return event;
  end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;
revoke all on table public.users from anon, public;
grant all on table public.users to authenticated, supabase_auth_admin;
create policy "Allow auth admin to read users" ON public.users as permissive for select to supabase_auth_admin using (true);

-- Helper function: create_user
create or replace function public.create_user(
    email text
) returns uuid
    security definer
    set search_path = auth
as $$
  declare
    user_id uuid;
begin
  user_id := extensions.uuid_generate_v4();

  insert into auth.users (id, email)
    values (user_id, email)
    returning id into user_id;

  return user_id;
end;
$$ language plpgsql;
