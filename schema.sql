create type public.app_permission as enum (
  'public.users.update',
  'public.users.select',
  'public.delete_user',
  'public.create_user',
  'public.transactions.select'
);
create type public.app_role as enum ('admin', 'user', 'guest');

create table public.users (
  id       uuid references auth.users not null primary key, -- uuid from auth.users
  username text,
  role     public.app_role default 'user'::public.app_role
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal supabase auth user.';

create table public.role_permissions (
  id         bigint generated by default as identity primary key,
  role       public.app_role not null,
  permission public.app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

create or replace function public.authorize(
  requested_permission public.app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
    from public.role_permissions
    where role_permissions.permission = authorize.requested_permission
      and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
    into bind_permissions;

  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

create policy "admin can update public.users" on public.users for update using (public.authorize('public.users.update'));
create policy "admin can select public.users" on public.users for select using (public.authorize('public.users.select'));

alter table public.role_permissions enable row level security;
alter table public.users enable row level security;
alter table public.users replica identity full;

create or replace function public.handle_new_user()
returns trigger as $$
declare
    first_name text := new.raw_user_meta_data->>'first_name';
    last_name  text := new.raw_user_meta_data->>'last_name';
    full_name  text := nullif(trim(coalesce(first_name, '') || ' ' || coalesce(last_name, '')), '');
begin
    insert into public.users (id, username, role)
    values (new.id, full_name, 'user')
    on conflict (id) do nothing;

    return new;
end;
$$ language plpgsql security definer set search_path = auth, public;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;

alter publication supabase_realtime add table public.users;

create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims    jsonb;
    user_role public.app_role;
  begin
    claims := event->'claims';
    select role
      into user_role
      from public.users
      where id = (event->>'user_id')::uuid;

    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    event := jsonb_set(event, '{claims}', claims);

    return event;
  end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;
revoke all on table public.users from anon, public;
grant all on table public.users to authenticated, supabase_auth_admin;
grant all on table auth.users to authenticated, supabase_auth_admin;
create policy "allow auth admin to read users" on public.users as permissive for select to supabase_auth_admin using (true);

create or replace function public.create_user(
    username text,
    password text,
    role public.app_role
) returns uuid
as $$
declare
    user_id uuid;
begin
    user_id := extensions.uuid_generate_v4();

    insert into public.users (id, username, role)
        values (user_id, username, role);

    insert into auth.users (id, email, role, encrypted_password)
        values (user_id, username, 'authenticated', extensions.crypt(password, extensions.gen_salt('bf')))
        returning id into user_id;

    return user_id;
end;
$$ language plpgsql security definer set search_path = auth, public;
grant execute on function public.create_user(text, text, public.app_role) to authenticated;

create or replace function public.delete_user(
    user_id uuid 
) returns void
as $$
begin
    if not public.authorize('public.delete_user') then
        raise exception 'insufficient privileges. must have public.delete_user permission.';
    end if;

    if not exists (select 1 from auth.users where id = user_id) then
        raise exception 'user with id % does not exist.', user_id;
    end if;

    delete from public.users
    where id = user_id;

    delete from auth.users
    where id = user_id;

    return;
end;
$$ language plpgsql security definer set search_path = auth, public;
grant execute on function public.delete_user(uuid) to authenticated;

create or replace function public.create_user_internal(
    email text,
    password text,
    role public.app_role,
    first_name text DEFAULT null,
    last_name text DEFAULT null,
    last_sign_in timestamptz DEFAULT null,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
) returns uuid as $$
declare
    user_id uuid;
    encrypted_pw text;
    user_role public.app_role;
begin
    user_id := extensions.gen_random_uuid();
    encrypted_pw := extensions.crypt(password, extensions.gen_salt('bf'));

    insert into auth.users (
        instance_id,
        id,
        aud,
        role,
        email,
        encrypted_password,
        email_confirmed_at,
        recovery_sent_at,
        last_sign_in_at,
        raw_app_meta_data,
        raw_user_meta_data,
        created_at,
        updated_at,
        confirmation_token,
        email_change,
        email_change_token_new,
        recovery_token
    ) 
    select
        '00000000-0000-0000-0000-000000000000',
        user_id,
        'authenticated',
        'authenticated',
        email,
        encrypted_pw,
        created_at,
        null,
        coalesce(last_sign_in, created_at),
        '{"provider":"email","providers":["email"]}',      
        jsonb_build_object(
            'sub', user_id::text,
            'email', email,
            'email_verified', 'true',
            'phone_verified', 'false',
            'first_name', first_name,
            'last_name', last_name
        ),
        created_at,
        coalesce(updated_at, created_at),
        '',
        '',
        '',
        '';
   
    insert into auth.identities (
        id,
        provider_id,
        user_id,
        identity_data,
        provider,
        last_sign_in_at,
        created_at,
        updated_at
    ) values (
        extensions.gen_random_uuid(),
        user_id,
        user_id,
        jsonb_build_object(
            'sub', user_id::text,
            'email', email,
            'email_verified', 'true',
            'phone_verified', 'false'
        ),
        'email',
        coalesce(last_sign_in, created_at),
        created_at,
        coalesce(updated_at, created_at)
    );

    user_role := role;
    update public.users set role = user_role where id = user_id;

    return user_id;
end;
$$ language plpgsql security definer set search_path = auth, public;
revoke execute on function public.create_user_internal(text, text, public.app_role, text, text, timestamptz, timestamptz, timestamptz) from authenticated, anon, public;

create or replace function public.create_user(
    email text,
    password text,
    role public.app_role,
    first_name text DEFAULT null,
    last_name text DEFAULT null,
    last_sign_in timestamptz DEFAULT null,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
) returns uuid as $$
begin
    if not public.authorize('public.create_user') then
        raise exception 'Insufficient privileges. Must have public.create_user permission.';
    end if;

    return public.create_user_internal(
        email,
        password,
        role,
        first_name,
        last_name,
        last_sign_in,
        created_at,
        updated_at
    );
end;
$$ language plpgsql security definer set search_path = auth, public;
grant execute on function public.create_user(text, text, public.app_role, text, text, timestamptz, timestamptz, timestamptz) to authenticated;

-- transactions

create type public.transaction_type as enum ('deposit', 'credit');
create type public.transaction_status as enum ('pending', 'completed', 'failed');
create type public.transaction_subtype as enum ('refund', 'reward', 'purchase');

create table public.transactions (
  id uuid primary key,
  user_id uuid references auth.users not null,
  description text,
  type public.transaction_type not null,
  subtype public.transaction_subtype not null,
  amount decimal(10, 2) not null,
  status public.transaction_status not null,
  created_at timestamp not null default now(),
  updated_at timestamp not null default now()
);

comment on table public.transactions is 'Stores all user transactions with their details.';
comment on column public.transactions.user_id is 'Foreign key referencing the user in the auth.users table.';
alter table public.transactions enable row level security;

create view transactions_with_username with (security_invoker = true) as
select 
    t.id as transaction_id, 
    u.username, 
    t.description, 
    t.amount, 
    t.type,
    t.subtype,
    t.status,
    t.created_at
from public.transactions t
join public.users u on t.user_id = u.id;

create policy "admin can select public.transactions" on public.transactions for select using (public.authorize('public.transactions.select'));
create policy "user can select public.transactions" on public.transactions for select using (public.authorize('public.transactions.select'));

create or replace function public.get_revenue_current_month()
returns jsonb
language plpgsql
as $$
declare
    start_date  timestamp;
    end_date    timestamp;
    date_range  text;
    total_value numeric;
begin
    if not public.authorize('public.transactions.select') then
        raise exception 'Insufficient privileges. Must have public.transactions.select permission.';
    end if;

    start_date := date_trunc('month', now());
    end_date   := now();

    date_range := to_char(start_date, 'fmdd fmmonth') || ' - ' 
                  || to_char(end_date, 'fmdd fmmonth');

    select coalesce(sum(amount), 0)
      into total_value
      from public.transactions
     where status = 'completed'
       and subtype in ('reward', 'purchase')
       and created_at >= start_date
       and created_at <= end_date;

    return (
       select jsonb_build_object(
         'type', 'month',
         'range', date_range,
         'total', total_value,
         'revenues', coalesce(
            jsonb_agg(
              jsonb_build_object(
                'subtype', t.subtype,
                'revenue', t.sub_amount
              )
            ),
            '[]'::jsonb
         )
       )
       from (
         select subtype, sum(amount) as sub_amount
           from public.transactions
          where status = 'completed'
            and subtype in ('reward', 'purchase')
            and created_at >= start_date
            and created_at <= end_date
          group by subtype
       ) t
    );
end;
$$;
grant execute on function public.get_revenue_current_month() to authenticated;

create or replace function public.get_revenue_current_week()
returns jsonb
language plpgsql
as $$
declare
    start_date  timestamp;
    end_date    timestamp;
    date_range  text;
    total_value numeric;
begin
    if not public.authorize('public.transactions.select') then
        raise exception 'Insufficient privileges. Must have public.transactions.select permission.';
    end if;
    start_date := date_trunc('week', now()::date + 1);
    end_date   := now();

    date_range := to_char(start_date, 'fmdd fmmonth') || ' - ' || to_char(end_date, 'fmdd fmmonth');

    select coalesce(sum(amount), 0)
      into total_value
      from public.transactions
     where status = 'completed'
       and subtype in ('reward', 'purchase')
       and created_at >= start_date
       and created_at <= end_date;

    return (
       select jsonb_build_object(
         'type', 'week',
         'range', date_range,
         'total', total_value,
         'revenues', coalesce(
            jsonb_agg(
              jsonb_build_object(
                'subtype', t.subtype,
                'revenue', t.sub_amount
              )
            ),
            '[]'::jsonb
         )
       )
       from (
         select subtype, sum(amount) as sub_amount
           from public.transactions
          where status = 'completed'
            and subtype in ('reward', 'purchase')
            and created_at >= start_date
            and created_at <= end_date
          group by subtype
       ) t
    );
end;
$$;
grant execute on function public.get_revenue_current_week() to authenticated;

insert into public.role_permissions (role, permission)
values
    ('admin', 'public.users.update'),
    ('admin', 'public.users.select'),
    ('admin', 'public.create_user'),
    ('admin', 'public.delete_user'),
    ('user', 'public.transactions.select'),
    ('admin', 'public.transactions.select');
